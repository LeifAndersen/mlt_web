Документация по инфраструктуре <verbatim> Copyright (C) 2004-2014
Meltytech, LLC Last Revision: 2004-10-08 Translator: Ruslan Popov
<radz@yandex.ru> Last Revision: 2006-01-06 </verbatim>

---+ Инфраструктура MLT

---++ Введение

Библиотека MLT является мультимедийной инфраструктурой разработанной для
телевизионного вещания и, соответственно, она предоставляет собой
расширяемую архитектуру для подключения новых A/V источников, фильтров,
переходов и устройств воспроизведения.

Инфраструктура является основным каркасом на основе которого создаются
приложения и сервисы использующие библиотеку MLT.

Сама инфраструктура предоставляет нечто большее, чем просто "абстрактные
классы" и утилиты для управления ресурсами такими как память, свойства,
динамическая подгрузка объектов и обслуживание самого экземпляра
библиотеки.

Данный документ разделён на три секции. Первая секция предоставляет
собой простой обзор библиотеки MLT, вторая секция показывает как можно
использовать библиотеку и заключительная секция показывает дизайн и
структуру библиотеки, ставя основной акцент на расширение возможностей.

---++ Целевая Аудитория

Данный документ можно рассматривать как "дорожную карту" по
инфраструктуре библиотеки, которая должна быть обязательно изучена тем,
кто желает разрабатывать исходный код на уровне библиотеки MLT.

Перечислим таких людей: 1 разработчики библиотеки; 1 разработчики
модулей; 1 разработчики приложений; 1 любой, кому интересна данная
библиотека.

Цель данного документа  объяснить использование интерфейсов, а не
описывать детали реализации библиотеки.

Данный документ не обязателен для чтения в случае MLT клиент-сервер
интеграции. Для этого надо обратиться к =valerie.txt= и =dvcp.txt=.

---+ Секция 1 - Основы

---++ Дизайн

Библиотека написана на языке C.

Библиотека соответствует стандарту C99 и зависит только от POSIX
библиотек.

Библиотека следует основной парадигме объекто-ориентированного дизайна
и, следовательно, в большинстве случаев использует шаблон "Производитель
(Producer)/Потребитель (Consumer)".

Библиотека использует обратную польскую нотацию для приложений A/V
эффектов.

Библиотека разработана так, чтобы быть нейтральной к используемому
пространству цветов, но реализованные в настоящее время модули, тем не
менее, в своём большинстве ориентированы на 8-ми битное YUV422
пространство цветов. В теории, эти модули могут быть в последствии
заменены.

Неопределённость данного срока подразумевается по всему документу.

---++ Структура и поток

Основной структурой "сети" библиотеки является простое соединение
"Производителя" к "Потребителю": <verbatim> +--------+ +--------+
|Producer|--&gt;|Consumer| +--------+ +--------+ </verbatim> Обычный
потребитель запрашивает объекты =MLT Frame= у производителя, производит
с объектами необходимые действия и закрывает их.

Общий беспорядок с терминологией производителя/потребителя, используемой
здесь, состоит в том, что потребитель может 'произвести' кое-что.
Например, =libdv= потребитель производит =DV= поток и кажется как-будто
=libdv= производитель потребляет этот поток. Однако, соглашения по
обозначениям относятся только к производителям и потребителям =MLT
Frame=.

Другими словами, производитель производит объекты =MLT Frame=, а
потребитель их потребляет.

По существу, =MLT Frame= предоставляет несжатое изображение и связанные
с ним звуковой поток.

Между производителем и потребителем могут помещаться фильтры: <verbatim>
+--------+ +------+ +--------+ |Producer|--&gt;|Filter|--&gt;|Consumer|
+--------+ +------+ +--------+ </verbatim> Сервис  это коллективное имя
для производителей, фильтров, преобразований и потребителей.

Взаимодействие между подсоединёнными потребителем и производителем или
сервисов выполняются в три шага: \* получение информации о кадре; \*
получение изображения; \* получение звука.

Библиотека использует "ленивую распаковку", т.е. изображение и и
связанный с ним звуковой поток не нуждаются в распаковке до первого
вызова соответствующих методов.

В основном, потребитель получает информацию из того, к кому он
подключен. Это означает, что многопоточность реализуется на стороне
потребителя и с его стороны предоставляется некая базовая
функциональность, которая будет гарантировать пропускную способность в
реальном времени.

---+ Секция 2  Использование

---++ Hello World

Перед тем как погрузиться в архитектурные дебри библиотеки следует
предоставить работающий пример.

Нижеприведённый код реализует медиа проигрыватель: <verbatim> \#include
&lt;stdio.h&gt; \#include &lt;unistd.h&gt; \#include <framework/mlt.h>

int main( int argc, char \*argv\[\] ) { // Initialise the factory if (
mlt\_factory\_init( NULL ) == 0 ) { // Create the default consumer
mlt\_consumer hello = mlt\_factory\_consumer( NULL, NULL );

           // Create via the default producer
           mlt_producer world = mlt_factory_producer( NULL, argv[ 1 ] );

           // Connect the producer to the consumer
           mlt_consumer_connect( hello, mlt_producer_service( world ) );

           // Start the consumer
           mlt_consumer_start( hello );

           // Wait for the consumer to terminate
           while( !mlt_consumer_is_stopped( hello ) )
               sleep( 1 );

           // Close the consumer
           mlt_consumer_close( hello );

           // Close the producer
           mlt_producer_close( world );

           // Close the factory
           mlt_factory_close( );
       }
       else
       {
           // Report an error during initialisation
           fprintf( stderr, "Unable to locate factory modules\n" );
       }

       // End of program
       return 0;

} </verbatim> Это простой пример. Он не предоставляет возможности
свободного перемещения по контенту или изменения конфигурации.

Первым шагом любого =MLT= приложения является инициализация фабрики,
которая удостоверяет, что окружение настроено и библиотека может
функционировать. Фабрика будет рассмотрена далее.

Все сервисы запускаются через фабрики, как это показано вызовами
=mlt\_factory\_consumer= и =mlt\_factory\_producer=. Для фильтров и
переходов существуют подобные фабрики. В =services.txt= описаны все
подробности обо всех стандартных сервисах библиотеки.

Использование значений =NULL= является особым случаем. Таким образом мы
запросили производителей и потребителей определённых по умолчанию.

Производителем по умолчанию является =fezzik=. Этот производитель
просматривает имена файлов, чтобы найти подходящий сервис и подключает
"нормализованные фильтры" (такие как масштабирование, деинтерлейсинг,
изменение частоты звука и нормализация полей кадра) к загруженному
контенту. Эти фильтры гарантируют, что потребитель получет именно то,
что запросил.

Потребителем по умолчанию является =sdl=. Комбинация из =fezzik= и =sdl=
предоставляет медиа проигрыватель.

В этом примере, мы подсоединили производитель и затем запустили
потребителя. Затем, мы подождали завершения потребителя (в нашем случае,
мы просто закрыли окно проигрывателя) и закрыли потребителя,
производителя и фабрику перед выходом из приложения.

Следует отметить, что потребитель является многопоточным, ожидание
некоторого события всегда требуется только после запуска и тольео перед
остановкой или закрытием потребителя.

Также следует отметить, что можно переопределить значения по умолчанию:
<verbatim> $ MLT\_CONSUMER=westley ./hello file.avi </verbatim> Таким
образом мы создадим =westley xml= документ на стандартном выводе.

<verbatim> $ MLT\_CONSUMER=westley MLT\_PRODUCER=avformat ./hello
file.avi </verbatim> Таким образом мы проиграем видео напрямую через
производитель =avformat=, что позволит нам обойти функции нормализации.
<verbatim> $ MLT\_CONSUMER=libdv ./hello file.avi &gt; /dev/dv1394
</verbatim> Такой вариант выполнит конвертацию файла =file.avi= в формат
=DV= и отправит контент на ваше =DV= устройство.

---++ Фабрики

Как показано в примере "Hello World", фабрики применяются для создания
сервисных объектов.

Сама библиотека не предоставляет никаких сервисов  сервисы
предоставляются в виде плагинов. Плагин  это организованная форма
(модуль) и модуль можут предоставлять множество сервисов различного
типа.

После инициализации фабрики все сконфигурированные сервисы готовы к
использованию.

Полный набор методов принадлежащих фабрике показан ниже: <verbatim> int
mlt\_factory\_init( char *prefix ); const char *mlt\_factory\_prefix( );
char *mlt\_environment( char *name ); mlt\_producer
mlt\_factory\_producer( char *name, void *input ); mlt\_filter
mlt\_factory\_filter( char *name, void *input ); mlt\_transition
mlt\_factory\_transition( char *name, void *input ); mlt\_consumer
mlt\_factory\_consumer( char *name, void *input ); void
mlt\_factory\_close( ); </verbatim> Метод =mlt\_factory\_prefix=
возвращает путь к каталогу с инсталлированными модулями. Путь может быть
определён с помощью метода =mlt\_factory\_init= или может быть задан
через переменную окружения =MLT\_REPOSITORY=. Если путь не определён, то
используется значение по умолчанию =$(INSTALLDIR)/shared/mlt/modules=.

Метод =mlt\_environment= предоставляет доступ только на чтение к
коллекции пар =name=value=, как показано в таблице приведённой ниже: |
*Переменная* | *Описание* | *Значения* | | MLT\_NORMALISATION | Система
цветности | =PAL= или =NTSC= | | MLT\_PRODUCER | Производитель по
умолчанию | =fezzik= или другой | | MLT\_CONSUMER | Потребитель по
умолчанию | =sdl= или другой | | MLT\_TEST\_CARD | Производитель для
тестовой карты по умолчанию | любой | Эти значения инициализируются из
переменных окружения имеющих такие же имена.

Как показано выше, производитель может быть создан с помощью
производителя "нормализация по умолчанию" и они могуть быть запрошены по
имени. Фильтры и переходы всегда запрашиваются по имени, для них не
существует значения по умолчанию.

---++ Свойства сервиса

Как показано в документе =services.txt=, у каждого сервиса есть свой
собственный набор свойств, через которые можно управлять поведением
сервиса.

Для того чтобы установить свойства сервиса следует получить
соответствующий объект свойств. Для производителя это делается следующим
образом: <verbatim> mlt\_properties properties =
mlt\_producer\_properties( producer ); </verbatim> Все сервисы имеют
соответствующий метод.

После получения данного объекта, все операции со свойствами сервиса
производятся напрямую с этим объектом, например: <verbatim>
mlt\_properties\_set( properties, "name", "value" ); </verbatim> Более
детальное описание объекта свойств будет приведено далее.

---++ Списки проигрывания

Таким образом, мы показали простой пример. Следующим шагом мы организуем
производителей в список проигрывания.

Давайте предположим, что мы адаптируем предыдущий пример и пожелаем
проиграть по очереди несколько файлов, т.е.: <verbatim> hello \*.avi
</verbatim> Вместо прямого вызова метода =mlt\_factory\_producer= мы
создадим новую функцию =create\_playlist=. Эта функция будет создавать
список проигрывания, создавая каждого производителя и добавляя его к
списку. <verbatim> mlt\_producer create\_playlist( int argc, char
\*\*argv ) { // We're creating a playlist here mlt\_playlist playlist =
mlt\_playlist\_init( );

       // We need the playlist properties to ensure clean up
       mlt_properties properties = mlt_playlist_properties( playlist );

       // Loop through each of the arguments
       int i = 0;
       for ( i = 1; i < argc; i ++ )
       {
           // Create the producer
           mlt_producer producer = mlt_factory_producer( NULL, argv[ i ] );

           // Add it to the playlist
           mlt_playlist_append( playlist, producer );

           // Close the producer (see below)
           mlt_producer_close( producer );
       }

       // Return the playlist as a producer
       return mlt_playlist_producer( playlist );

} </verbatim> Следует отметить, что мы закрыли производителя после его
добавления. В действительности, то что мы делаем - это закрытие нашей
ссылки к нему, т.к. список проигрывания создаёт свою собственную ссылку
на производителя и закроет эту ссылку во время удаления списка
проигрывания.

Такая функциональность ссылок была введена в версии =0.1.2=. Данная
функциональность 100% совместима с ранним механизмом регистрации ссылки
и деструктора в свойствах объекта списка проигрывания.

При добавлении нескольких экземпляров одного производителя будут создано
соответствующее количество ссылок на него.

Теперь, мы заменяем эти строчки в функции =main=: <verbatim> // Create a
normalised producer mlt\_producer world = mlt\_factory\_producer( NULL,
argv\[ 1 \] ); </verbatim> на: <verbatim> // Create a playlist
mlt\_producer world = create\_playlist( argc, argv ); </verbatim> и мы
теперь будем проигрывать список клипов.

---++ Фильтры

Вставка фильтров между производителем и потребителем производится
следующим образом. Сначала фильтр подключается к производителю, затем к
предыдущему фильтру, а последний фильтр к потребителю.

Пример: <verbatim> // Create a producer from something mlt\_producer
producer = mlt\_factory\_producer( ... );

       // Create a consumer from something
       mlt_consumer consumer = mlt_factory_consumer( ... );

       // Create a greyscale filter
       mlt_filter filter = mlt_factory_filter( "greyscale", NULL );

       // Connect the filter to the producer
       mlt_filter_connect( filter, mlt_producer_service( producer ), 0 );

       // Connect the consumer to filter
       mlt_consumer_connect( consumer, mlt_filter_service( filter ) );

</verbatim> Подобно производителям и потребителям, фильтрами можно
управлять через их объект свойств. Для этого используют метод
=mlt\_filter\_properties=.

Дополнительный аргумент метода подключения фильтра является важным, так
как оно определяем трек на котором будет работать фильтр. Для простых
производителей и листов проигрывания существует только один трек (0) и
как вы увидите в следующей секции даже обработка нескольких треков
приводит в результате к одному треку.

---++ Подключаемые Фильтры

Все сервисы могут иметь подключенные фильтры.

Рассмотрим следующий пример: <verbatim> // Create a producer
mlt\_producer producer = mlt\_factory\_producer( NULL, clip );

// Get the service object of the producer mlt\_producer service =
mlt\_producer\_service( producer );

// Create a filter mlt\_filter filter = mlt\_factory\_filter(
"greyscale" );

// Create a playlist mlt\_playlist playlist = mlt\_playlist\_init( );

// Attach the filter to the producer mlt\_service\_attach( producer,
filter );

// Construct a playlist with various cuts from the producer
mlt\_playlist\_append\_io( producer, 0, 99 ); mlt\_playlist\_append\_io(
producer, 450, 499 ); mlt\_playlist\_append\_io( producer, 200, 399 );

// We can close the producer and filter now mlt\_producer\_close(
producer ); mlt\_filter\_close( filter ); </verbatim> При работе этого
куска кода, для каждого кадра в списке проигрывания будет применён
фильтр "оттенки серого".

Затем, каждый клип может имет свои собственные подключенные фильтры,
которые применяются после фильтров производителя. Пример: <verbatim> //
Create a new filter filter = mlt\_factory\_filter( "invert", NULL );

// Get the second 'clip' in the playlist producer =
mlt\_playlist\_get\_clip( 1 );

// Get the service object of the clip service = mlt\_producer\_service(
producer );

// Attach the filter mlt\_service\_attach( producer, filter );

// Close the filter mlt\_filter\_close( filter ); </verbatim> Даже сам
список проигрывания может иметь подключенный фильтр: <verbatim> //
Create a new filter filter = mlt\_factory\_filter( "watermark",
"+Hello.txt" );

// Get the service object of the playlist service =
mlt\_playlist\_service( playlist );

// Attach the filter mlt\_service\_attach( service, filter );

// Close the filter mlt\_filter\_close( filter ); </verbatim>
Естественно, что список проигрывания, будучи производителем, может быть
помещён в другой список проигрывания, а фильтры могут быть подключены к
медиа контенту или к созданному новому списку и так далее.

The main advantage of attached filters is that they remain attached and
don't suffer from the maintenance problems associated with items being
inserted and displacing calculated in/out points - this being a major
issue if you exclusively use the connect or insert detached filters in a
multitrack field (описано далее).

---++ Введение в микширование

Микширование является простейшим способом использования перехода между
соседними клипами в списке проигрывания.

Рассмотрим следующий список проигрывания: <verbatim>
+-+----------------------+----------------------------+-+ |X|A |B |X|
+-+----------------------+----------------------------+-+ </verbatim>
Предположим, что "X" является "чёрным клипом" длиной в 50 кадров.

Когда вы запустите проигрывание этого списка, вы получите 50 кадров
чёрного, которое резко переключится в клип "A", затем следует
переключение на клип "B" и, наконец, опять 50 кадров чёрного.

Намерение состоит в том, чтобы преобразовать список проигрывания похожий
на это: <verbatim>
+-+---------------------+-+------------------------+-+ |X|A |A|B |B| |A|
|B| |X| +-+---------------------+-+------------------------+-+
</verbatim> Причем клип, относящийся к двум клипам, представляет собой
переход. Следует отметить, что представление второго списка проигрывания
короче чем первого, это очевидно, один 50 кадровый переход между двумя
клипами уменшает время проигрывания на 50 кадров.

Микширование производится с помощью метода =mlt\_playlist\_mix=.
Предположим, что у вас есть список проигрывания подобный описанному выше
и чтобы произвести первое микширование, необходимо сделать следующее:
<verbatim> // Create a transition mlt\_transition transition =
mlt\_factor\_transition( "luma", NULL );

// Mix the first and second clips for 50 mlt\_playlist\_mix( playlist,
0, 50, transition );

// Close the transition mlt\_transition\_close( transition );
</verbatim> Этот код выполнит первое микширование. Таким же образом
производится микширование остальных клипов. В результате мы получим
новый клип в списке проигрывания, соответственно следующим микшированием
будет микширование третьего и четвёртого клипов.

Подсказка, для упрощения определение номера следующего клипа можно
сделать так: <verbatim> // Get the number of clips on the playlist int i
= mlt\_playlist\_count( );

// Iterate through them in reverse order while ( i -- ) { // Create a
transition mlt\_transition transition = mlt\_factor\_transition( "luma",
NULL );

// Mix the first and second clips for 50 mlt\_playlist\_mix( playlist,
i, 50, transition );

// Close the transition mlt\_transition\_close( transition ); }
</verbatim> Существуют также другие методы, например, использование
метода =mlt\_playlist\_join= для объединения текущего клипа и ещё одного
(вы можете определить был ли новый клип создан или нет с помощью
сравнения длины списка проигрывания до и после вызова метода).

Во время работы метод =mlt\_playlist\_mix= генерирует трактор и
мнультитрек, как будет описано ниже. Подобно подключаемым фильтрам,
микширование упрощает жизнь при вставке элементов в список проигрывания.

Также следует отметить, что микширование позволяет упростить
пользовательский интерфейс, вместо упорного использования сложного
многотрекового объекта, вы можете выполнять множество действий на одном
треке. Следовательно, дополнительные треки могут быть использованы для
дублирования звуковой дорожки, микширования или композиции, которые
позиционируются независимо и не подвергаются влиянию при работе с
другими треками. Но если вам требуется претенциозный, запутывающий и
расстраивающий интерфейс, то эта функциональность тоже поддерживается
;-).

---++ Практичность и оптимизация

В предыдущих двух секциях я описал некоторую мощную функциональность
разработанную для упрощения использования библиотеки MLT. Тем не менее,
важно пояснить, что происходит когда вы пытаетесь вставить переход между
двумя частями одного и того же видеоматериала.

Любой, кто знаком с компрессией видео, будет знать, что быстрый переход
по материалу не всегда обходится без последствий с точки зрения
производительности. Таким образом, если вам требуется получить два кадра
одного клипа для перехода, это может привести к значительной нагрузке,
что будет очень неприятно, особенно, если вы выполняете работу в
реальном времени.

Как же это преодолеть?

В действительности, это очень просто, вызываете метод
=mlt\_producer\_optimise= для объекта верхнего уровня после модификации
и библиотека сама определит как его обработать. Метод определяет
максимальное число перекрывающихся экземпляров внутри объекта, создаёт
необходимое количество клонов и назначает клонам соответствующие
индексы.

В приведённом выше примере, вы просто вызываете: <verbatim> // Optimise
the playlist mlt\_producer\_optimise( mlt\_playlist\_producer( playlist
) ); </verbatim> после выполнения микширования. Следует отметить, что
вызов этого метода автоматически выполняется для *deserialised
westleys*.

---++ Мультитрековость и Переходы

Поддержка мультитрековости требует следующее: 1. Необходимо, чтобы
производитель и потребитель взаимодействовали между собой через один
кадр; 1. Возможность сериализации и работы через "сеть" (или граф
фильтра).

Мы можем отобразить мультитрековость стандартным способом: <verbatim>
+-----------------+ +-----------------------+ 0: |a1 | |a2 |
+---------------+-+--------------------------+-+---------------------+
1: |b1 | +------------------------------+ </verbatim> Перекрывающиеся
области треков 0 и 1 должны использовать некоторый переход. Без
использования перехода, кадры от =b1= и =a2= будут отображаться на время
перекрытия треков (по умолчанию, трек с наибольшим номером получает
преимущество в отображении).

Библиотека MLT имеет мультитрековый объект, но он не является
производителем, в том смысле, что он может быть напрямую подключен к
потребителю и всё будет работать. Потребитель будет рассматривать его
как обычного производителя и, с точки зрения мультитрековости, вы не
увидите ничего с трека 1, кроме переходов между клипами, промежуток
между =a1= и =a2= будет заполнен тестовыми кадрами.

Такое случается из-за того, что потребитель получает по одному кадру от
производителя, в то в ремя как мультитрек предоставляет один кадр для
каждого трека. Что-то где-то должно удостоверяться, что все кадры
получены от мультитрекового объекта и выбирать правильный кадр.

Следовательно, библиотека предоставляет прослойку для мультитрека,
который называется *трактором*. Задаче трактора является отслеживание
того, что треки получаются, кадр выбирается нужный и что он себя ведёт
как производитель.

Таким образом, мультитрек отдаёт поток трактору как показано ниже:
<verbatim> +----------+ |multitrack| | +------+ | +-------+ |
|track0|-|---&gt;|tractor| | +------+ | |  | | | |   | | +------+ | |  
| | |track1|-|---&gt;|---o---|---&gt; | +------+ | | / | | | | / | |
+------+ | |/ | | |track2|-|---&gt;| | | +------+ | +-------+
+----------+ </verbatim> Имея такую комбинацию, мы теперь можем
подсоединять мультитреки к потребителям. The last non-test card will be
retrieved and passed on.

Треки могут быть производителями, списками проигрывания и даже другими
тракторами.

Теперь мы желаем вставить фильтры и переходы между мультитреком и
трактором. Это можно сделать напрямуя с помощью вставки фильтров между
ними. Но такой метод потребует большого количества подсоединений между
левыми и правыми производителями и потребителями, т.е. мы должны иметь
возможность автоматизировать данный процесс.

Так в соответствии с нашей сельскохозяйственной темой, родилось понятие
"поля". Мы "выращиваем" фильтры и переходы в поле, и трактор тянет
мультитрек (подумайте о комбайне :-)) по полю и производит кадр.

Концептуально, мы можем видеть это так: <verbatim> +----------+
|multitrack| | +------+ | +-------------+ +-------+ |
|track0|-|---&gt;|field |---&gt;|tractor| | +------+ | | | |  | | | |
filters | |   | | +------+ | | and | |   | | |track1|-|---&gt;|
transitions |---&gt;|---o---|---&gt; | +------+ | | | | / | | | | | | /
| | +------+ | | | |/ | | |track2|-|---&gt;| |---&gt;| | | +------+ |
+-------------+ +-------+ +----------+ </verbatim> Таким образом, на
следует сначала создать трактор, через который мы получаем мультитрек и
остальные объекты. Мы можем поработать с этими объектами и затем
подключить трактор к потребителю.

А вот так это выглядит со стороны потребителя: <verbatim>
+-----------------------------------------------+ |tractor
+--------------------------+ | | +----------+ | +-+ +-+ +-+ +-+ | | |
|multitrack| | |f| |f| |t| |t| | | | | +------+ | | |i| |i| |r| |r| | |
| | |track0|-|---&gt;| |l|- -&gt;|l|- -&gt;|a|---&gt;|a|| | | | +------+
| | |t| |t| |n| |n| | | | | | | |e| |e| |s| |s| | | | | +------+ | | |r|
|r| |i| |i| | | | | |track1|-|- -&gt;|
|0|---&gt;|1|---&gt;|t|---&gt;|t|-|--o---&gt; | | +------+ | | | | | |
|i| |i| | /| | | | | | | | | |o| |o| |/ | | | +------+ | | | | | | |n|
|n| | | | | |track2|-|- -&gt;| | |- -&gt;| |---&gt;|0|- -&gt;|1|/| | | |
+------+ | | | | | | | | | | | | | +----------+ | +-+ +-+ +-+ +-+ | | |
+--------------------------+ |
+-----------------------------------------------+ </verbatim> Надеемся,
что пример прояснит всё.

Предположим, что нам необходимо выводить некую метку в нашем примере. Мы
уже расширили код примера для проигрывания нескольких клипов и теперь
добавим текстовую метку "Hello World" в верхний левый угол кадра:
<verbatim> mlt\_producer create\_tracks( int argc, char \*\*argv ) { //
Create the tractor mlt\_tractor tractor = mlt\_tractor\_new( );

       // Obtain the field
       mlt_field field = mlt_tractor_field( tractor );

       // Obtain the multitrack
       mlt_multitrack multitrack = mlt_tractor_multitrack( tractor );

       // Create a composite transition
       mlt_transition transition = mlt_factory_transition( "composite", "10%/10%:15%x15%" );

       // Create track 0
       mlt_producer track0 = create_playlist( argc, argv );

       // Create the watermark track - note we NEED fezzik for scaling here
       mlt_producer track1 = mlt_factory_producer( "fezzik", "pango" );

       // Get the length of track0
       mlt_position length = mlt_producer_get_playtime( track0 );

       // Set the properties of track1
       mlt_properties properties = mlt_producer_properties( track1 );
       mlt_properties_set( properties, "text", "Hello\nWorld" );
       mlt_properties_set_position( properties, "in", 0 );
       mlt_properties_set_position( properties, "out", length - 1 );
       mlt_properties_set_position( properties, "length", length );
       mlt_properties_set_int( properties, "a_track", 0 );
       mlt_properties_set_int( properties, "b_track", 1 );

       // Now set the properties on the transition
       properties = mlt_transition_properties( transition );
       mlt_properties_set_position( properties, "in", 0 );
       mlt_properties_set_position( properties, "out", length - 1 );

       // Add our tracks to the multitrack
       mlt_multitrack_connect( multitrack, track0, 0 );
       mlt_multitrack_connect( multitrack, track1, 1 );

       // Now plant the transition
       mlt_field_plant_transition( field, transition, 0, 1 );

       // Close our references
       mlt_producer_close( track0 );
       mlt_producer_close( track1 );
       mlt_transition_close( transition );

       // Return the tractor
       return mlt_tractor_producer( tractor );

} </verbatim> Всё, что нам теперь необходимо - заменить эти строчки в
функции =main=: <verbatim> // Create a playlist mlt\_producer world =
create\_playlist( argc, argv ); </verbatim> на: <verbatim> // Create a
watermarked playlist mlt\_producer world = create\_tracks( argc, argv );
</verbatim> и у нас есть средство для проигрывания клипов с навязчивой
меткой - только этого нам и не хватало, не так ли?

Тот же самый результат можно достичь с помощью простого фильтра
=watermark=, вставленным между производителем и потребителем.

---+ Секция 3 - Структура и дизайн

---++ Иерархия класса

Инфраструктура библиотеки MLT имеет иерархию ОО класса, который состоит
из следующих публичных классов и абстракций: <verbatim> mlt\_properties
mlt\_frame mlt\_service mlt\_producer mlt\_playlist mlt\_tractor
mlt\_filter mlt\_transition mlt\_consumer mlt\_deque mlt\_pool
mlt\_factory </verbatim> Каждый класс указанный выше может
рассматриваться как расширение классов, описанных выше и левее.

Следующие секции описывают функциональность предоставляемой
инфраструктуры. Это ключевые компоненты, понимание которых необходимо
для работы с библиотекой.

---+++ Класс =mlt\_properties=

Класс свойств является базовым классом для классов кадра и сервиса.

Он разработан для организации эффективной таблицы переходов для
различных типов информации, таких как строки, целые, числа с плавающей
точкой, указатели на данные и структуры данных.

Каждое свойство имеет уникальное название.

Обычное использование класса: <verbatim> // 1. Create a new, empty
properties set; mlt\_properties properties = mlt\_properties\_new( );

// 2. Assign the value "world" to the property "hello";
mlt\_properties\_set( properties, "hello", "world" );

// 3. Retrieve and print the value of "hello"; printf( "%s",
mlt\_properties\_get( properties, "hello" ) );

// 4. Reassign "hello" to "world!"; mlt\_properties\_set( properties,
"hello", "world!" );

// 5. Retrieve and print the value of "hello"; printf( "%s",
mlt\_properties\_get( properties, "hello" ) );

// 6. Assign the value "0" to "int"; mlt\_properties\_set( properties,
"int", "0" );

// 7. Retrieve and print the integer value of "int"; printf( "%d",
mlt\_properties\_get\_int( properties, "int" ) );

// 8. Assign the integer value 50 to "int2"; mlt\_properties\_set\_int(
properties, "int2", 50 );

// 9. Retrieve and print the double value of "int2"; printf( "%s",
mlt\_properties\_get( properties, "int2" ) ); </verbatim> Шаги со
второго по пятый демонстрируют уникальность имени свойства, набор
операций над существующим "именем" изменяют его значение. Они также
освобождают память, ассоциированную с предыдущим значением. Следует
отметить, что таким же образом можно изменить тип значения.

Шаги с шестого по седьмой демонстрируют, как объект обрабатывает
распаковку данных из строк. Текстовое значение "0" было определено,
целое значение 0 было получено.

Шаги с восьмого по девятый демонстрируют, как объект обрабатывает
упаковку в строки.

Для отображения всех пар имя/значение можно организовать небольшую
итерацию: <verbatim> for ( i = 0; i &lt; mlt\_properties\_count(
properties ); i ++ ) printf( "%s = %s", mlt\_properties\_get\_name(
properties, i ), mlt\_properties\_get\_value( properties, i ) );
</verbatim> Следует отметить, что свойства получаются в том порядке, в
каком они были определены.

Свойства также используются для хранения указателей на области памяти.
Это делается так: <verbatim> uint8\_t \*image = malloc( size );
mlt\_properties\_set\_data( properties, "image", image, size, NULL, NULL
); </verbatim> В этом примере, мы указываем, что указатель может быть
получен из объекта обратным запросом =get\_data=: <verbatim> image =
mlt\_properties\_get\_data( properties, "image", &size ); </verbatim>
или: <verbatim> image = mlt\_properties\_get\_data( properties, "image",
NULL ); </verbatim> если мы не желаем узнавать размер.

Две вещи: 1. Выделенная память остаётся после закрытия объекта до тех
пока вы не определите деструктор. Для вышеописанного случая, это может
быть сделано так: <verbatim> mlt\_properties\_set\_data( properties,
"image", image, size, free, NULL ); </verbatim> При закрытии объекта или
при изменении значения "image" будет вызван деструктор. 1. Строковое
значение возвращаемое методом =mlt\_properties\_get= будет равно =NULL=.
Обычно не требуется упаковка изображения в строку, но для других
структур это может понадобиться. Вы можете указать упаковщик в виде
последнего аргумента, если это необходимо (его определение =char
*serialise( void * )=).

Свойства также предоставляют более навороченные возможности.

Объект имеет возможность наследовать все упаковываемые значения от
другого такого же объекта: <verbatim> mlt\_properties\_inherit( this,
that ); </verbatim> Объект имеет возможность копировать свой набор
свойств для другого объекта: <verbatim> mlt\_properties\_mirror( this,
that ); </verbatim> После вызова этого метода весь набор упаковывающихся
значений передаётся от =this= к =that=.

---+++ Класс =mlt\_deque=

Стеки и очереди являются основными компонентами инфраструктуру MLT.
Будучи ленивыми мы выбрали реализацию "Double Ended Queue" (=deque=),
которая объединяет функциональность обоих.

Методы класса определены ниже: <verbatim> mlt\_deque mlt\_deque\_init(
); int mlt\_deque\_count( mlt\_deque this ); int mlt\_deque\_push\_back(
mlt\_deque this, void *item ); void *mlt\_deque\_pop\_back( mlt\_deque
this ); int mlt\_deque\_push\_front( mlt\_deque this, void *item ); void
*mlt\_deque\_pop\_front( mlt\_deque this ); void
*mlt\_deque\_peek\_back( mlt\_deque this ); void
*mlt\_deque\_peek\_front( mlt\_deque this ); void mlt\_deque\_close(
mlt\_deque this ); </verbatim> Стековые операции используются в ряде
случаев: \* (обратная польская нотация) операции с изображениями и
звуком; \* выделение памяти.

Операции с очередями используются в случаях: \* основного класса
потребителя; \* реализация потребителя может требовать ещё больше
очередей.

---+++ Класс =mlt\_pool=

Библиотека MLT предоставляет возможности для работы с памятью через этот
класс. После инициализации, методы данного класса могут рассматриваться
как замена стандартным функциям =malloc/realloc/free=.

Необходимость в таких методах обусловлена известностью о неэффективности
операций =malloc/free=, особенно при работе с большими блоками памяти
(обработка изображений). На Linux, функция =malloc= оптимизирована для
выделения памяти блоками менее 128 КБ. Блоки памяти такого размера и
менее остаются в памяти процесса для последующего повторного
использования, предотвращая использование функций ядра для повторяющихся
выделений/освобождений небольших блоков памяти. Тем не менее, работа с
блоками памяти большего размера сказывается на производительности.

Дизайн данного класса просто хранит список стеков. Один стек отвечает за
память размером 2^n байт (где n находится между 8 и 31). Когда
происходит выделение памяти, необходимый размер округляется до
следующего значения степени двойки, запрашивается стек для этого размера
памяти и элемент помещается туда или создаётся, если стек был пуст.

Каждый элемент имеет *заголовок*, размещённый прямо перед возвращаемым
адресом. Заголовок хранит указатель на стек, к которому принадлежит
данный элемент.

При освобождении элемента, мы запрашиваем заголовок, получаем стек и
выталкиваем его обратно.

Таким образом, с точки зрения програмиста мы пользуемся "стандартными"
функциями: <verbatim> void *mlt\_pool\_alloc( int size ); void
*mlt\_pool\_realloc( void *ptr, int size ); void mlt\_pool\_release(
void *release ); </verbatim>

---+++ Класс =mlt\_frame=

Этот объект определён следующим образом: <verbatim> +------------+
|frame | +------------+ | properties | | image stack| | audio stack|
+------------+ </verbatim> Жизненный цикл кадра может быть представлен
следующим образом:

*Этап* | *Производитель* | *Фильтр* | *Потребитель* |  
0.0 | | | Запрос кадра |  
0.1 | | Получение запроса. Запрос кадра. | |  
0.2 | Получение запроса. Генерация кадра для текущей позиции. Увеличение
указателя позиции | | |  
0.3 | | Получение кадра. Обновление кадра. | |  
0.4 | | | Получение кадра |

Следует отметить, что ни фильтр, ни потребитель не имеют никакого
понятия о текущей позиции до тех пор, пока они не получат кадр. Скорость
и текущая позиция являются свойствами производителя, которые назначаются
объекту кадра при его создании.

Шаг =0.3= является критичным. Если фильтр определяет, что кадр для него
интересен, то он должен воздействовать на кадр через его свойства и/или
A/V стеки.

Предположим, что фильтр работает с видео и с аудио, следовательно он
должен поместить данные и методы в стеки, которые произведут необходимую
обработку. Это может быть сделано с помощью методов
=mlt\_frame\_push\_image= и =mlt\_frame\_push\_audio=. Чтобы определить
интересы фильтра, стеки должны содержать следующее: \* стек изображения:
<verbatim>\[ producer\_get\_image \] \[ data1 \] \[ data2 \] \[
filter\_get\_image \]</verbatim> \* стек звука: <verbatim>\[
producer\_get\_audio \] \[ data \] \[ filter\_get\_audio \]</verbatim>

Методы =filter\_get= вызываются автоматически, когда потребитель
вызывает метод =get\_image= для кадра.

*Этап* | *Производитель* | *Фильтр* | *Потребитель* |  
1.0 | | | =frame\_get\_image= |  
1.1 | | =filter\_get\_image=: получаем data2 и data1,
=frame\_get\_image= | |  
1.2 | =producer\_get\_image=, генерирует изображение | | |  
1.3 | | Получение изображения. Обновление изображения | |  
1.4 | | | Получение изображения |

Очевидно, что если фильтр не интересует изображение, то он не должен
работать с соответствующим стеком. В этом случае потребитель получит
изображение напрямую от производителя.

Аналогично обрабатывается и звук: | *Этап* | *Производитель* | *Фильтр*
| *Потребитель* | | 2.0 | | | =frame\_get\_audio= | | 2.1 | |
=filter\_get\_audio=: получаем данные, =frame\_get\_audio= | | | 2.2 |
=producer\_get\_audio=, генерация звука | | | | 2.3 | | Получение звука.
Обновление звука. | | | 2.4 | | | Получение звука. |

И наконец, когда потребитель закончит обрабатывать кадр, он должен
закрыть его.

Следует отметить, что потребитель имеет возможность не обрабатывать
изображение или звук для любого взятого кадра, особенно при работе в
реальном времени. Об этом будет написано далее.

По умолчанию, кадр имеет следующие свойства:

*Имя* | *Описание* | *Значения* |  
=\_position= | Текущая позиция производителя | от =0= до =n= |  
=\_speed= | Скорость производителя | =double= |  
=image= | Сгенерированное изображение | =NULL= или указатель |  
=alpha= | Сгенерированная маска прозрачности | =NULL= или указатель |  
=width= | Ширина изображения | |  
=height= | Высота изображения | |  
=normalised\_width= | Нормализованная ширина изображения | =720= |  
=normalised\_height= | Нормализованная высота изображения | =576= или
=480= |  
=progressive= | Прогрессивная или черезстрочкая развёртка | =0= или =1=
|  
=top\_field\_first= | Верхнее поле идёт первым | =0= или =1= |  
=audio= | Сгенерированный звук | =NULL= или указатель |  
=frequency= | Частота оцифровки звука | |  
=channels= | Количество каналов звука | |  
=samples= | Сэмплы звука | |  
=aspect\_ratio= | Аспект изображения | =double= |  
=test\_image= | Нет изображения | =0= или =1= |  
=test\_audio= | Нет звука | =0= или =1= |

Потребитель может добавить следующие свойства, которые воздействуют на
стандартное поведение кадра:

*Имя* | *Описание* | *Значения* |  
=test\_card\_producer= | Синтезирование тестовых изображений из
указанного источника | =NULL= или указатель |  
=consumer\_aspect\_ratio= | Применять указанный аспект к
синтезированному тестовому изображению | =double= |  
=rescale.interp= | Использовать этот метод масштабирования для тестового
изображения | "строка" |

Назначение свойств понятно из их названия, но свойства
=normalised\_width= и =normalised\_height= требуют небольшого
разъяснения. Они необходимы для того, чтобы удостовериться, что эффекты
используются для PAL или NTSC изображения независимо от размеров
изображения использующихся в производителе/потребителе.

Флаги =test\_image= и =test\_audio= используются для определения надо ли
синтезировать тестовые изображения или звук или нет.

Дополнительные свойства могут быть назначены реализацией производителя,
а фильтры, переходы и потребители имеют возможность добавлять
дополнительные свойства для выполнения специфических запросов. Всё это
описано в =modules.txt=.

Вот полный список методов: <verbatim> mlt\_frame mlt\_frame\_init( );
mlt\_properties mlt\_frame\_properties( mlt\_frame this ); int
mlt\_frame\_is\_test\_card( mlt\_frame this ); int
mlt\_frame\_is\_test\_audio( mlt\_frame this ); double
mlt\_frame\_get\_aspect\_ratio( mlt\_frame this ); int
mlt\_frame\_set\_aspect\_ratio( mlt\_frame this, double value );
mlt\_position mlt\_frame\_get\_position( mlt\_frame this ); int
mlt\_frame\_set\_position( mlt\_frame this, mlt\_position value ); int
mlt\_frame\_get\_image( mlt\_frame this, uint8\_t **buffer,
mlt\_image\_format *format, int *width, int *height, int writable );
uint8\_t *mlt\_frame\_get\_alpha\_mask( mlt\_frame this ); int
mlt\_frame\_get\_audio( mlt\_frame this, int16\_t **buffer,
mlt\_audio\_format *format, int *frequency, int *channels, int *samples
); int mlt\_frame\_push\_get\_image( mlt\_frame this, mlt\_get\_image
get\_image ); mlt\_get\_image mlt\_frame\_pop\_get\_image( mlt\_frame
this ); int mlt\_frame\_push\_frame( mlt\_frame this, mlt\_frame that );
mlt\_frame mlt\_frame\_pop\_frame( mlt\_frame this ); int
mlt\_frame\_push\_service( mlt\_frame this, void *that ); void
*mlt\_frame\_pop\_service( mlt\_frame this ); int
mlt\_frame\_push\_audio( mlt\_frame this, void *that ); void
*mlt\_frame\_pop\_audio( mlt\_frame this ); void mlt\_frame\_close(
mlt\_frame this ); </verbatim>

---+++ Класс =mlt\_service=

Базовый класс сервиса расширяет свойства, позволяя иметь 0..m входов и
0..n выходов, как показано ниже: <verbatim> +-----------+ - -&gt;| |-
-&gt; - -&gt;| Service |- -&gt; - -&gt;| | +-----------+ | properties|
+-----------+ </verbatim> Потомки сервиса налагают ограничения на
количество подключаемых входов и выходов, предоставляя простой набор
свойств. Typically, the service instance is encapsulated by the
descendent in order for it to ensure that its connection rules are
followed.

При создании сервис не определяет никаких переменных. Следует упомянуть,
что производители, фильтры и переходы могут быть упакованы (например,
через =westley= потребителя) и необходимо различать переменные, которые
могут быть упакованы от тех, которые не могут. Мы используем соглашение,
что переменные неподлежащие упаковке начинаются с подчёркивания.

Публичный интерфейс имеет следующие методы: <verbatim> int
mlt\_service\_init( mlt\_service this, void \*child ); mlt\_properties
mlt\_service\_properties( mlt\_service this ); int
mlt\_service\_connect\_producer( mlt\_service this, mlt\_service
producer, int index ); int mlt\_service\_get\_frame( mlt\_service this,
mlt\_frame\_ptr frame, int index ); void mlt\_service\_close(
mlt\_service this ); </verbatim> Обычно, только прямые потомки сервисов
требуют использование данных методов. Разработчики рекомендуется
использовать эти методы при определении новых сервисов.

---+++ Класс =mlt\_producer=

У производителя есть один выход и ни одного входа: <verbatim>
+-----------+ | | | Producer |---&gt; | | +-----------+ | service |
+-----------+ </verbatim> Производитель предоставляет абстракцию для
чтения файлов, работы с потоками или другим вводом видео и аудио.

После создания производитель имеет следующие свойства: | *Название* |
*Описание* | *Значения* | | =mlt\_type= | Тип производителя |
=mlt\_producer= | | =\_position= | Позиция производителя (номер кадра) |
От =0= до =n= | | =\_speed= | Скорость производителя | =double= | |
=fps= | Количество выпускаемых кадров в секунду | =25= или =29.97= | |
=in= | Номер кадра во входящем потоке | От =0= до =length-1= | | =out= |
Номер кадра в выходящем потоке | От =0= до =length-1= | | =length=
|Количество кадров во входящем потоке | От =0= до =n= | |
=aspect\_ratio= | Аспект кадра источника | От =0= до =n= | | =eof= |
Конец клипа | =pause= или =loop= | | =resource= | Аргумент конструктора,
т.е. имя файла | =<resource>= |

Дополнительные свойства могут быть предоставлены реализацией
производителя.

Публичный интерфейс класса состоит из следующих методов: <verbatim>
mlt\_producer mlt\_producer\_new( ); int mlt\_producer\_init(
mlt\_producer this, void \*child ); mlt\_service mlt\_producer\_service(
mlt\_producer this ); mlt\_properties mlt\_producer\_properties(
mlt\_producer this ); int mlt\_producer\_seek( mlt\_producer this,
mlt\_position position ); mlt\_position mlt\_producer\_position(
mlt\_producer this ); mlt\_position mlt\_producer\_frame( mlt\_producer
this ); int mlt\_producer\_set\_speed( mlt\_producer this, double speed
); double mlt\_producer\_get\_speed( mlt\_producer this ); double
mlt\_producer\_get\_fps( mlt\_producer this ); int
mlt\_producer\_set\_in\_and\_out( mlt\_producer this, mlt\_position in,
mlt\_position out ); mlt\_position mlt\_producer\_get\_in( mlt\_producer
this ); mlt\_position mlt\_producer\_get\_out( mlt\_producer this );
mlt\_position mlt\_producer\_get\_playtime( mlt\_producer this );
mlt\_position mlt\_producer\_get\_length( mlt\_producer this ); void
mlt\_producer\_prepare\_next( mlt\_producer this ); void
mlt\_producer\_close( mlt\_producer this ); </verbatim>

---+++ Класс =mlt\_filter=

Публичный интерфейс класса состоит из следующих методов: <verbatim> int
mlt\_filter\_init( mlt\_filter this, void \*child ); mlt\_filter
mlt\_filter\_new( ); mlt\_service mlt\_filter\_service( mlt\_filter this
); mlt\_properties mlt\_filter\_properties( mlt\_filter this );
mlt\_frame mlt\_filter\_process( mlt\_filter this, mlt\_frame that );
int mlt\_filter\_connect( mlt\_filter this, mlt\_service producer, int
index ); void mlt\_filter\_set\_in\_and\_out( mlt\_filter this,
mlt\_position in, mlt\_position out ); int mlt\_filter\_get\_track(
mlt\_filter this ); mlt\_position mlt\_filter\_get\_in( mlt\_filter this
); mlt\_position mlt\_filter\_get\_out( mlt\_filter this ); void
mlt\_filter\_close( mlt\_filter ); </verbatim>

---+++ Класс =mlt\_transition=

Публичный интерфейс класса состоит из следующих методов: <verbatim> int
mlt\_transition\_init( mlt\_transition this, void \*child );
mlt\_transition mlt\_transition\_new( ); mlt\_service
mlt\_transition\_service( mlt\_transition this ); mlt\_properties
mlt\_transition\_properties( mlt\_transition this ); int
mlt\_transition\_connect( mlt\_transition this, mlt\_service producer,
int a\_track, int b\_track ); void mlt\_transition\_set\_in\_and\_out(
mlt\_transition this, mlt\_position in, mlt\_position out ); int
mlt\_transition\_get\_a\_track( mlt\_transition this ); int
mlt\_transition\_get\_b\_track( mlt\_transition this ); mlt\_position
mlt\_transition\_get\_in( mlt\_transition this ); mlt\_position
mlt\_transition\_get\_out( mlt\_transition this ); mlt\_frame
mlt\_transition\_process( mlt\_transition this, mlt\_frame a\_frame,
mlt\_frame b\_frame ); void mlt\_transition\_close( mlt\_transition this
); </verbatim>

---+++ Класс =mlt\_consumer=

Публичный интерфейс класса состоит из следующих методов: <verbatim> int
mlt\_consumer\_init( mlt\_consumer this, void \*child ); mlt\_service
mlt\_consumer\_service( mlt\_consumer this ); mlt\_properties
mlt\_consumer\_properties( mlt\_consumer this ); int
mlt\_consumer\_connect( mlt\_consumer this, mlt\_service producer ); int
mlt\_consumer\_start( mlt\_consumer this ); mlt\_frame
mlt\_consumer\_get\_frame( mlt\_consumer this ); mlt\_frame
mlt\_consumer\_rt\_frame( mlt\_consumer this ); int mlt\_consumer\_stop(
mlt\_consumer this ); int mlt\_consumer\_is\_stopped( mlt\_consumer this
); void mlt\_consumer\_close( mlt\_consumer ); </verbatim>

---+++ Специальные производители

Есть два основных типа специальных производителей - это списки
проигрывания и тракторы.

Рассмотрим их.

---++++ Класс =mlt\_playlist=

Публичный интерфейс класса состоит из следующих методов: <verbatim>
mlt\_playlist mlt\_playlist\_init( ); mlt\_producer
mlt\_playlist\_producer( mlt\_playlist this ); mlt\_service
mlt\_playlist\_service( mlt\_playlist this ); mlt\_properties
mlt\_playlist\_properties( mlt\_playlist this ); int
mlt\_playlist\_count( mlt\_playlist this ); int mlt\_playlist\_clear(
mlt\_playlist this ); int mlt\_playlist\_append( mlt\_playlist this,
mlt\_producer producer ); int mlt\_playlist\_append\_io( mlt\_playlist
this, mlt\_producer producer, mlt\_position in, mlt\_position out ); int
mlt\_playlist\_blank( mlt\_playlist this, mlt\_position length );
mlt\_position mlt\_playlist\_clip( mlt\_playlist this, mlt\_whence
whence, int index ); int mlt\_playlist\_current\_clip( mlt\_playlist
this ); mlt\_producer mlt\_playlist\_current( mlt\_playlist this ); int
mlt\_playlist\_get\_clip\_info( mlt\_playlist this,
mlt\_playlist\_clip\_info \*info, int index ); int
mlt\_playlist\_insert( mlt\_playlist this, mlt\_producer producer, int
where, mlt\_position in, mlt\_position out ); int mlt\_playlist\_remove(
mlt\_playlist this, int where ); int mlt\_playlist\_move( mlt\_playlist
this, int from, int to ); int mlt\_playlist\_resize\_clip( mlt\_playlist
this, int clip, mlt\_position in, mlt\_position out ); void
mlt\_playlist\_close( mlt\_playlist this ); </verbatim>

---++++ Класс =mlt\_tractor=

Публичный интерфейс класса состоит из следующих методов: <verbatim>

</verbatim>

-- Main.RaD - 06 Jan 2006
